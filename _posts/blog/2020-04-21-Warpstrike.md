---
layout: single
title:  "WIP: FFXV Warpstrike"
date:   2020-03-25 16:32:56 -0600
categories: [blog] 
author_profile: true
author: "Shrinath Rao"
permalink: /:categories/:title
---

For this project, I really wanted to re-learn unreal since I had only used it a few times and I wanted to familiarize myself with the C++ side of things. After looking at Mix and Jam, I realized I could remake the warpstrike quite well in Unity3D but in a lot of ways, had no earthly idea how to replicate it in Unreal. This especially included the shader system.

Thankfully, game engines and especially coding with them, while might be quite different in languages, nuances and in philosophy of style all revolve around similar loops and concepts. While, not as used in this project, I still had an Update() function for frame based events and I still had animation events to help time and activate special effects, and more on specific frames.

I started the project by doing some research on Unreal's coding guidelines and framework, and after I had watched a few videos I jumped right into a c++ project. The editor confused me at first, since I didn't necassarily have everything I wanted right at my finger tips (especially when it came down to getting basic input). After importing a fun model, and some animations, I opened up visual studio. 

I edited my headerfile and made sure that I had everything I needed to build a "player character" right there. It was unlike Unity in that I mean that I usually try to separate features into individual scripts, this way I can reuse say a shooting script elsewhere), I only basically had one class to editing (which in my case inherited from the UE4 actor class). I used some of Unreal's existing movement components, which I found to be an interesting change of pace since it worked perfectly right off the bat for what I wanted to do. At first I felt quite guilty about using premade components- this was very much unlike you-nity where you make the scripts. But in a way it was refreshing to have basic  movement up and running with nothing to worry about in about 5 minutes. 

At this point I had a basic moving T-pose character with no working camera, so I added a spring arm component to my player class, and setup the heirarchy in relation to my camera. After a few modification and tweaks here and there, I had a follow camera with a spring arm component! (This would allow the player to back into a wall without the camera going through the wall). I also at this staged worked out some funny physics bugs (things like locking rotation on different axis etc...)

After changing my static mesh to a skeletal mesh, I got down to making my animation blueprints after this, which was similar to unity in that I still had an easy, visual way of making state diagrams, but unlike Unity, the way you went about them was very different. I made a special class for the animator that would expose certain variables from the player allowing the blueprint to appropriately assign an animation based on my physics using direction, speed and a blendspace. The blendspace was pretty much just like how I used blendtrees in Unity, so not much changed there. The blendspace gave the character a fluid movement system.

Now that I had all of that done, I needed to work on the attack animation. I added another state and appropriately worked out the logic for it and added it into my animation state diagram. I got the input handeled for it in C++ and now the meat of the project began- the shader. I hadn't actually focused on making shaders before, it wasn't something I had really ever needed to do for any of my prototypes. But luckily a seminar course taught by Ben Cloward on youtube, and my previous knowledge of Modeling and Texturing from my last semester at college really helped me. I understood what each of the base nodes were on my existing object, and all I really had to learn were the tools that Unreal was giving me to create. Not that that wasn't a challenge though, its just that I wasn't starting at level 0 in terms of understanding. I used Fresnel and some opacity changes to achieve the effect after a day of learning and a day of tinkering, I decided it was time to cut it off where it was. 

To recap, now I had a working player with movement and attacks, and I also had a shader I could use. The only issue at this stage, was that I didn't have enemies, and I didn't have a lock-target mechanic so that the player could teleport to an existing object. To be honest, the enemy part was the easiest of my problems, I made a new actor class called actor. I did notice using an actor iterator come up on google, but that seemed just like using a "FindGameObjectWithTag(string)". It really wouldn't be a viable option. I made it such that the player object had an array of enemy objects. Every time an enemy was instantiated, it would automatically add itself to the player's enemy object array. On button input, it would select the nearest enemy in the array. As this was just a prototype, I didn't restrict it via range, but of course that's a very simple if conditional to write out later on. 

Now that my player knew where all the nearby enemies were, it had an easy job when I hit the attack button- play the attack animation, do shader stuff and on the right frame run a function that would teleport the player in front of the enemy! The first bit was already done, the last bit took me about 2-3 lines of code. To teleport to a selected enemy, I made an animation event at the appropriate frame and teleported the player to the enemy. 

To add in the shader, I had to seriously scrutinize the warpstrike shaders timing- how it faded in, faded out, and when exactly in the attack animtion it proc'ed. I looked up a video that showed it off and took a good amount of time trying to at least match the timing, and I also went back and revised the shader once more. I actually had a hard time finding code that would use shaders like this one appropriately, so I took the hint and used blueprints to implement it (timing curves to handle the fade in fade out of the frenel and opacity). That was where I left the project!

